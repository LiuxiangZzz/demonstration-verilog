# 自动映射 vs 手动配置

## 快速答案

**部分自动，部分手动：**
- ✅ **内部逻辑映射**：**自动**（综合工具完成）
- ❌ **端口到引脚映射**：**手动**（需要约束文件）
- ✅ **布局布线**：**自动**（实现工具完成）
- ❌ **时钟和时序约束**：**手动**（需要约束文件）

## 详细说明

### ✅ 自动完成的部分

#### 1. 内部逻辑 → FPGA 资源（自动）

**这部分完全自动，你不需要做任何事！**

```verilog
// 你的代码
module alu(
    input [31:0] a, b,
    output [31:0] result
);
    assign result = a + b;
endmodule
```

**工具自动完成：**
- 识别这是加法运算
- 选择使用 LUT 实现
- 优化逻辑
- 分配到合适的 LUT 位置

**你不需要：**
- ❌ 指定使用哪个 LUT
- ❌ 指定逻辑如何实现
- ❌ 手动优化代码

#### 2. 内存 → BRAM（自动）

```verilog
// 你的代码
reg [31:0] mem [0:16383];  // 64KB 内存
```

**工具自动完成：**
- 识别这是存储器
- 选择使用 BRAM 还是分布式 RAM
- 分配 BRAM 资源
- 优化内存访问

**你不需要：**
- ❌ 指定使用哪个 BRAM
- ❌ 手动管理内存

#### 3. 布局布线（自动）

**工具自动完成：**
- 将逻辑单元放到 FPGA 的合适位置
- 连接各个逻辑单元
- 优化时序和面积

**你不需要：**
- ❌ 指定逻辑放在哪里
- ❌ 手动连接信号

### ❌ 需要手动配置的部分

#### 1. 顶层端口 → 物理引脚（必须手动）

**这部分必须手动配置！**

```verilog
// 你的代码
module top(
    input clk,
    input rst,
    output [31:0] pc_out
);
```

**你必须手动指定：**
```tcl
# 约束文件中
set_property PACKAGE_PIN E3 [get_ports clk]      # ← 必须手动指定
set_property PACKAGE_PIN C12 [get_ports rst]     # ← 必须手动指定
set_property PACKAGE_PIN U16 [get_ports {pc_out[0]}]  # ← 必须手动指定
```

**为什么？**
- 工具不知道你的板子是什么
- 工具不知道你想把信号连接到哪里
- 不同的板子引脚不同

#### 2. 时钟约束（必须手动）

**你必须手动指定：**
```tcl
create_clock -period 10.000 -name clk [get_ports clk]  # ← 必须手动指定
```

**为什么？**
- 工具不知道时钟频率
- 不同板子时钟频率不同（50MHz、100MHz 等）
- 需要时钟信息进行时序分析

#### 3. I/O 标准（必须手动）

**你必须手动指定：**
```tcl
set_property IOSTANDARD LVCMOS33 [get_ports clk]  # ← 必须手动指定
```

**为什么？**
- 不同板子使用不同的电压标准（3.3V、2.5V 等）
- 工具不知道你的板子标准

## 完整流程对比

### 自动流程（你不需要管）

```
Verilog 代码
    ↓
综合工具（自动）
    ├─ 识别逻辑
    ├─ 选择资源（LUT/FF/BRAM）
    ├─ 优化代码
    └─ 生成网表
    ↓
实现工具（自动）
    ├─ 布局（自动选择位置）
    ├─ 布线（自动连接）
    └─ 优化时序
    ↓
比特流文件
```

### 手动配置（你必须做）

```
约束文件 (constraints.xdc)
    ├─ 指定引脚映射（必须）
    ├─ 指定时钟频率（必须）
    ├─ 指定 I/O 标准（必须）
    └─ 指定时序约束（可选）
    ↓
工具读取约束文件
    ↓
应用到自动流程中
```

## 实际例子

### 例子1：ALU 加法器（完全自动）

**你的代码：**
```verilog
assign result = a + b;
```

**工具自动：**
- ✅ 识别加法运算
- ✅ 使用 LUT 实现
- ✅ 优化逻辑
- ✅ 分配到 FPGA 位置

**你不需要做任何事！**

### 例子2：PC 输出到 LED（需要手动）

**你的代码：**
```verilog
output [15:0] pc_out;
```

**工具自动：**
- ✅ 识别这是输出端口
- ✅ 分配内部资源

**你必须手动：**
- ❌ 指定连接到哪个引脚
- ❌ 指定 I/O 标准

**约束文件（你必须写）：**
```tcl
set_property PACKAGE_PIN U16 [get_ports {pc_out[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {pc_out[0]}]
```

## 总结表格

| 项目 | 是否自动 | 说明 |
|------|---------|------|
| 内部逻辑 → LUT | ✅ 自动 | 综合工具完成 |
| 寄存器 → FF | ✅ 自动 | 综合工具完成 |
| 内存 → BRAM | ✅ 自动 | 综合工具完成 |
| 布局布线 | ✅ 自动 | 实现工具完成 |
| **端口 → 引脚** | ❌ **手动** | **必须写约束文件** |
| **时钟约束** | ❌ **手动** | **必须写约束文件** |
| **I/O 标准** | ❌ **手动** | **必须写约束文件** |
| 时序优化 | ✅ 自动 | 工具自动优化 |

## 你需要做什么？

### 必须做的（手动配置）

1. **创建约束文件** (`constraints.xdc`)
2. **指定引脚映射**（哪些端口连接到哪些引脚）
3. **指定时钟频率**
4. **指定 I/O 标准**

### 不需要做的（自动完成）

1. ❌ 指定逻辑如何实现
2. ❌ 指定使用哪个 LUT/FF/BRAM
3. ❌ 手动布局布线
4. ❌ 优化代码（工具会自动优化）

## 你的项目

### 当前状态

**自动完成的部分：**
- ✅ CPU 的所有内部逻辑（ALU、控制单元、流水线等）
- ✅ 内存映射到 BRAM
- ✅ 布局布线

**需要你手动配置的部分：**
- ❌ 顶层端口到引脚的映射（当前约束文件中引脚是注释掉的）
- ❌ 时钟约束（已配置，但需要确认引脚）
- ❌ I/O 标准（已配置）

### 下一步

你需要：
1. 打开 `constraints.xdc` 或 `constraints_nexys_a7_200t.xdc`
2. 取消注释引脚分配部分
3. 根据你的实际需求修改引脚号

**或者：**
- 如果只是仿真，不需要引脚约束
- 如果要下载到板子，必须配置引脚约束

